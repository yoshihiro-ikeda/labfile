// -*- mode: java; tab-width: 4; -*-

import java.io.RandomAccessFile;
import java.io.FileInputStream;
import java.io.PrintStream;

import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.nio.charset.Charset;

import java.io.IOException;
import java.io.FileNotFoundException;

import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Comparator;
import java.util.Collections;

import jp.ertl.utils.Getopts;

/**
 * Add measurment code to C source which generated by RTW-EC
 *
 * <pre>
 * usage: AddMeasurement [-v] [-o output.c] [-m output.h] [-p prefix]
 *         [-i include] [-b blocks.csv] -h header source
 * </pre>
 *
 * @version 0.1
 */
public class AddMeasurement {
	/**
	 * Block information
	 */
	private static class Block {
		/**
		 * hierarchy block name as &lt;Root&gt;/AAA, &lt;S1&gt;/BBB
		 */
		private String block;

		/**
		 * subsystem name as &lt;Root&gt; or &lt;S1&gt;
		 */
		private String system;

		/**
		 * Simulink block name
		 */
		private String name;

		/**
		 * BLXML Block name
		 */
		private String blockName;

		/**
		 * system ID, if &gt;S11&lt; is 11.
		 */
		private int systemId;

		/**
		 * counter(index) of block code
		 */
		private int blockCount = -1;

		/**
		 * counter(index) of update code
		 */
		private int updateCount = -1;

		/**
		 * block ID Number
		 */
		private int id = -1;

		/**
		 * Constructor
		 *
		 * @param block hierarchy system/block
		 * @param system system name
		 * @param prefix BLXML prefix block name
		 * @param name Simulink block name
		 */
		Block(String block, String system, String prefix, String name) {
			this.block = block;
			this.system = system;
			this.name = name;
			this.blockName = canonicalize(new String(prefix + "_" + name));

			if (system.equals("<Root>")) {
				systemId = 0;
			} else {
				String sNum = system.substring(2, system.length() - 1);
				systemId = Integer.parseInt(sNum);
			}

			blockNameMap.put(block, this.blockName);
			blockMap.put(block, this);

			if (verbose) {
				System.out.println("* System=" + system
								   + ", name=" + name
								   + " => " + blockName);
			}
		}

		/**
		 * get hierarchy block name
		 *
		 * @return hierarchy block name
		 */
		public String getBlock() {
			return block;
		}

		/**
		 * get system name
		 *
		 * @return system name
		 */
		public String getSystem() {
			return system;
		}

		/**
		 * get Simulink block name
		 *
		 * @return Simulink block name
		 */
		public String getName() {
			return name;
		}

		/**
		 * get BLXML block name
		 *
		 * @return BLXML block name
		 */
		public String getBlockName() {
			return blockName;
		}

		/**
		 * get system ID
		 *
		 * @return system ID
		 */
		public int getSystemId() {
			return systemId;
		}

		/**
		 * get counter(index) of block code
		 *
		 * @return block code counter
		 */
		public int getBlockCount() {
			return blockCount;
		}

		/**
		 * increment counter of block code
		 *
		 * @return block code counter
		 */
		public int incrementBlockCount() {
			return ++blockCount;
		}

		/**
		 * get counter(index) of update code
		 *
		 * @return block update code counter
		 */
		public int getUpdateCount() {
			return updateCount;
		}

		/**
		 * increment counter of update code
		 *
		 * @return block update code counter
		 */
		public int incrementUpdateCount() {
			return ++updateCount;
		}

		/**
		 * set block ID Number
		 *
		 * @param id block ID Number
		 */
		public void setId(int id) {
			this.id = id;
		}

		/**
		 * get block ID Number
		 *
		 * @return block ID Number
		 */
		public int getId() {
			return id;
		}
	}

	/**
	 * range of code
	 */
	private static class Range {
		/**
		 * start of range
		 */
		protected int start;

		/**
		 * end of range
		 */
		private int end;

		/**
		 * constructor for Range
		 *
		 * @param start start point
		 * @param end end point
		 */
		public Range(int start, int end) {
			this.start = start;
			this.end = end;
		}

		/**
		 * get start of range
		 *
		 * @return a start of range
		 */
		public int getStart() {
			return start;
		}

		/**
		 * get end f range
		 *
		 * @return an end of range
		 */
		public int getEnd() {
			return end;
		}
	}

	/**
	 * subsystem type
	 */
	private static enum SubsystemType { NONE, ATOMIC, ENABLED, TRIGGERED,
										ENABLED_TRIGGERED, ACTION, ITERATOR };
	/**
	 * pointer type (not change order)
	 */
	private static enum PointType { INCLUDE,
									STEP_BEGIN,
									START, INSERT, STOP, DELETE,
									REPLACE, SKIP,
									STEP_END };

	/**
	 * point base class
	 */
	private static class PointBase extends Range {
		/**
		 * point type
		 */
		private PointType type;

		/**
		 * Constructor
		 *
		 * @param type point type
		 * @param start start of range
		 * @param end end of range
		 */
		public PointBase(PointType type, int start, int end) {
			super(start, end);
			this.type = type;
		}

		/**
		 * Constructor
		 *
		 * @param type a type of point
		 * @param point a point
		 */
		public PointBase(PointType type, int point) {
			this(type, point, -1);
		}

		/**
		 * get type of point
		 *
		 * @return PointType
		 */
		public PointType getType() {
			return type;
		}

		/**
		 * get Point (alias of getStart())
		 *
		 * @return point
		 */
		public int getPoint() {
			return getStart();
		}

		/**
		 * compare
		 *
		 * @param a compare target
		 *
		 * @return a result of compare
		 */
		public int compareTo(PointBase a) {
			int x = start - a.start;
			if (x == 0) {
				return type.ordinal() - a.type.ordinal();
			}
			return x;
		}
	}

	/**
	 * Comparator for PointBase
	 */
	private static class PointBaseComparator
		implements Comparator<PointBase> {

		public int compare(PointBase a, PointBase b) {
			return a.compareTo(b);
		}
	}

	/**
	 * SkipPoint class
	 *
	 */
	private static class SkipPoint extends PointBase {
		/**
		 * Constructor
		 *
		 * @param start start of range
		 * @param end end of range
		 */
		public SkipPoint(int start, int end) {
			super(PointType.SKIP, start, end);
		}
	}

	/**
	 * RepacePoint class
	 */
	private static class ReplacePoint extends PointBase {
		/**
		 * replace text
		 */
		private String replace;

		/**
		 * Constructor
		 *
		 * @param start start of range
		 * @param end end of range
		 * @param replace replace text
		 */
		public ReplacePoint(int start, int end, String replace) {
			super(PointType.REPLACE, start, end);
			this.replace = replace;
		}

		/**
		 * get replace text
		 *
		 * @return replace text
		 */
		public String getReplace() {
			return replace;
		}
	}

	/**
	 * InsertPoint class
	 */
	private static class InsertPoint extends PointBase {
		/**
		 * insert text
		 */
		private String insertText;

		/**
		 * Constructor
		 *
		 * @param point a point
		 * @param insertText a insert text
		 */
		public InsertPoint(int point, String insertText) {
			super(PointType.INSERT, point, -1);
			this.insertText = insertText;
		}

		/**
		 * get insert text
		 *
		 * @return a insert text
		 */
		public String getInsertText() {
			return insertText;
		}
	}

	/**
	 * DeletePoint class
	 */
	private static class DeletePoint extends PointBase {
		/**
		 * Constructor
		 *
		 * @param point a point
		 * @param insertText a insert text
		 */
		public DeletePoint(int start, int end) {
			super(PointType.DELETE, start, end);
		}
	}

	/**
	 * MeasurePoint class
	 */
	private static class MeasurePoint extends PointBase {
		/**
		 * measured Block
		 */
		private Block block;
		/**
		 * is Update Code?
		 */
		private boolean update;

		/**
		 * Constructor
		 *
		 * @param type a type of point
		 * @param point a point
		 * @param block measured block
		 * @param update <code>true</code> is update code
		 */
		public MeasurePoint(PointType type, int point,
							Block block, boolean update) {
			super(type, point);
			this.block = block;
			this.update = update;
		}

		/**
		 * get Block
		 *
		 * @return Block instance
		 */
		public Block getBlock() {
			return block;
		}

		/**
		 * is Update?
		 *
		 * @return <code>true</code> update code
		 */
		public boolean isUpdate() {
			return update;
		}
	}

	/**
	 * TID infomation class
	 */
	private static class TIDInfo {
		private int tidIndex;
		private int startOfCondition;
		private int endOfCondition;

		public TIDInfo(int tidIndex,
					   int startOfCondition, int endOfCondition) {
			this.tidIndex = tidIndex;
			this.startOfCondition = startOfCondition;
			this.endOfCondition = endOfCondition;
		}

		public int getTidIndex() {
			return tidIndex;
		}

		public int getStartOfCondtion() {
			return startOfCondition;
		}

		public int getEndOfCondition() {
			return endOfCondition;
		}
	}

	/**
	 * save state entry
	 */
	private static class SaveState {
		/**
		 * start of comment
		 */
		public int startComment;

		/**
		 * end of comment
		 */
		public int endComment;

		/**
		 * start of statement
		 */
		public int startStatement;

		/**
		 * end of startStatement
		 */
		public int endStatement;

		/**
		 * start of block(if then block)
		 */
		public int startBlock;

		/**
		 * end of block(if then block)
		 */
		public int endBlock;

		/**
		 * TID index
		 */
		public TIDInfo tidInfo;

		/**
		 * parse point
		 */
		public int parsePoint;

		/**
		 * end of code
		 */
		public int codeEnd;

		/**
		 * start of a block's comment
		 */
		public int startBlockComment;

		/**
		 * current Block(instance)
		 */
		public Block currentBlock;

		/**
		 * is updade code
		 */
		public boolean isUpdate;

		/**
		 * has if condtion
		 */
		public boolean hasIf;

		/**
		 * preamble code
		 */
		public CharBuffer preamble;

		/**
		 * postamble code
		 */
		public CharBuffer postamble;

		/**
		 * restart flag
		 */
		public boolean restart;

		/**
		 * constructor
		 *
		 * @param startComment a start of comment
		 * @param endComment an end of comment
		 * @param startStatement a start of statement
		 * @param endStatement an end of statement
		 * @param startBlock a start of block(if-then block)
		 * @param endBlock an end of block(if-then block)
		 * @param tidInfo TID information
		 * @param parsePoint parse point
		 * @param codeEnd an end of code
		 * @param startBlockComment a start of block's comment
		 * @param currentBlock current Block(instance)
		 * @param isUpdate is update
		 * @param hasIf has if condtion
		 * @param restart restart flag
		 */
		public SaveState(int startComment, int endComment,
						 int startStatement, int endStatement,
						 int startBlock, int endBlock,
						 TIDInfo tidInfo, int parsePoint, int codeEnd,
						 int startBlockComment,
						 Block currentBlock, boolean isUpdate,
						 boolean hasIf,
						 CharBuffer preamble, CharBuffer postamble,
						 boolean restart) {
			this.startComment = startComment;
			this.endComment = endComment;
			this.startStatement = startStatement;
			this.endStatement = endStatement;
			this.startBlock = startBlock;
			this.endBlock = endBlock;
			this.tidInfo = tidInfo;
			this.parsePoint = parsePoint;
			this.codeEnd = codeEnd;
			this.startBlockComment = startBlockComment;
			this.currentBlock = currentBlock;
			this.isUpdate = isUpdate;
			this.hasIf = hasIf;
			this.preamble = preamble;
			this.postamble = postamble;
			this.restart = restart;
		}

		/**
		 * constructor
		 *
		 * @param parsePoint parse point
		 * @param codeEnd an end of code
		 */
		public SaveState(int parsePoint, int codeEnd) {
			this.startComment = -1;
			this.endComment = -1;
			this.startStatement = -1;
			this.endStatement = -1;
			this.startBlock = -1;
			this.endBlock = -1;
			this.tidInfo = null;
			this.parsePoint = parsePoint;
			this.codeEnd = codeEnd;
			this.startBlockComment = -1;
			this.currentBlock = null;
			this.isUpdate = false;
			this.hasIf = false;
			this.preamble = null;
			this.postamble = null;
			this.restart = false;
		}
	}

	/**
	 * verbose
	 */
	private static boolean verbose = false;

	/**
	 * output macro file name
	 */
	private static String outputMacroName = "macro.h";

	/**
	 * prefix
	 */
	private static String macroPrefix = "";

	/**
	 * include files
	 */
	private static List<String> includeFiles = new ArrayList<String>();

	/**
	 * Header match pattern
	 */
	private static Pattern
		beginHierarchy = Pattern.compile("^\\s*\\*\\s*Here\\s+is\\s+the"
										 + "\\s+system\\s+hierarchy\\s+"
										 + "for\\s+this\\s+model\\s*$",
										 Pattern.MULTILINE);

	/**
	 * block hierachy pattern
	 */
	private static Pattern
		blockHierarchy = Pattern.compile("^\\s*\\*\\s*("
										 + "'(<(Root|S\\d+)>)'"
										 + "\\s*"
										 + ":"
										 + "\\s+"
										 + "'([^']+)'\\s*)?$",
										 Pattern.MULTILINE);

	/**
	 * include and step function pattern
	 */
	private static Pattern
		stepFunction = Pattern.compile("^(void\\s+"
									   + "([_\\p{Alpha}][_\\p{Alnum}]+_step)"
									   + "\\s*\\(\\s*void\\s*\\)\\s*$\\v"
									   + "^\\{$\\v)"
									   + "|"
									   + "(\\s*#\\s*include\\s+.*$\\v)"
									   + "|"
									   + "^(void\\s+"
									   + "([_\\p{Alpha}][_\\p{Alnum}]+_initialize)"
									   + "\\s*\\(\\s*void\\s*\\)\\s*$\\v"
									   + "^\\{$\\v)",
									   Pattern.MULTILINE);

	/**
	 * TID match pattern
	 */
	private static Pattern
		tidPattern = Pattern.compile("^\\s*if\\s*\\("
									 + "("
									 + "[_\\p{Alpha}][_\\p{Alnum}]*"
									 + "->Timing\\.TaskCounters\\."
									 + "(TID\\[(\\d+)\\])[^\\)]*"
									 + ")"
									 + "\\)",
									 Pattern.MULTILINE);

	/**
	 * if condtion match pattern
	 */
	private static Pattern
		ifPattern = Pattern.compile("^\\s*if\\s*\\("
									+ "(.*)"
									+ "\\)\\s*\\{\\s*$\\v",
									Pattern.MULTILINE | Pattern.DOTALL);

	/**
	 * Block Comment
	 */
	private static Pattern
		blockMark = Pattern.compile("^\\s*/?\\*\\s*"
									+ "("				// 1
									+ "("				// 2
									+ "(End\\s+of)"		// 3
									+ "|"
									+ "(Update\\s+for)"	// 4
									+ ")"
									+ "\\s+"
									+ ")?"
									+ "("				// 5
									+ "S-Function\\s+\"[^\"]*\""
									+ "(\\s+Block)?"	// 6
									+ "|"
									+ "Outputs\\s+for\\s+(.*)\\s+SubSystem" // 7
									+ "|"
									+ "[\\p{Alpha}][^:]*"
									+ ")"
									+ "\\s*:\\s+'?"
									+ "("				// 8
									+ "(<"				// 9
									+ "(Root|S\\d+)"	// 10
									+ ">)"
									+ "/"
									+ "("				// 11
									+ "ConcatBufferAt(.*)In\\d+" // 12
									+ "|"
									+ "TmpSignal\\s+"
									+ "ConversionAt(.*)Inport\\d+" // 13
									+ "|"
									+ "([^':]*[\\p{Alnum}])" // 14
									+ ")"
									+ ")'?"
									+ "\\s+"
									+ "(incorporates:|\\*/?)\\s*$\\v",
									Pattern.MULTILINE);

	private static final int indexEndOf = 3;
	private static final int indexUpdateOf = 4;
	private static final int indexType = 5;
	private static final int indexSfUpdate = 6;
	private static final int indexSubSys = 7;
	private static final int indexBlock = 8;
	private static final int indexSystem = 9;
	private static final int indexCCB = 12;
	private static final int indexSC = 13;
	private static final int indexName = 14;

	/**
	 * base rate update
	 */
	private static Pattern
		blockEndMark = Pattern.compile("^\\s*"
									   + "/\\*"
									   + "\\s*Update\\s+absolute\\s+"
									   + "time\\s+for\\s+base\\s+rate\\s*"
									   + "\\*/");

	/**
	 * hierarchy map
	 */
	private static Map<String, String>
		hierarchyMap = new HashMap<String, String>();

	/**
	 * hierarchy block to BLXML block name map
	 * (Key: hierarchy block, value: BLXML Block)
	 */
	private static Map<String, String>
		blockNameMap = new HashMap<String, String>();

	/**
	 * hierarchy block to Block instance map
	 * (Key: hierarchy block, value: Block instance)
	 */
	private static Map<String, Block>
		blockMap = new HashMap<String, Block>();

	/**
	 * Point List
	 */
	private static List<PointBase>
		measurePointList = new ArrayList<PointBase>();

	/**
	 * start of comment
	 */
	private static int startComment = -1;

	/**
	 * end of comment
	 */
	private static int endComment = -1;

	/**
	 * start of statement
	 */
	private static int startStatement = -1;

	/**
	 * end of startStatement
	 */
	private static int endStatement = -1;

	/**
	 * start of block(if then block)
	 */
	private static int startBlock = -1;

	/**
	 * end of block(if then block)
	 */
	private static int endBlock = -1;

	/**
	 * TID index
	 */
	private static TIDInfo tidInfo = null;

	/**
	 * parse point
	 */
	private static int parsePoint = -1;

	/**
	 * end of code
	 */
	private static int codeEnd;

	/**
	 * start of block's comment
	 */
	private static int startBlockComment = -1;

	/**
	 * current Block(instance)
	 */
	private static Block currentBlock = null;

	/**
	 * is updade code
	 */
	private static boolean isUpdate = false;

	/**
	 * has if condtion
	 */
	private static boolean hasIf = false;

	/**
	 * preamble code
	 */
	public static CharBuffer preamble = null;

	/**
	 * postamble code
	 */
	public static CharBuffer postamble = null;

	/**
	 * restart flag
	 */
	private static boolean restart = false;

	/**
	 * parse state stack
	 */
	private static List<SaveState> stateStack = new ArrayList<SaveState>();

	/**
	 * step function name
	 */
	private static String stepFunctionName;

	/**
	 * initialize function name
	 */
	private static String initializeFunctionName;

	/**
	 * "step function" macro
	 */
	private static final String
		stepFunctionMacroName = "MEASUREMENT_STEP_FUNCTION";

	/**
	 * "initialize function" macro
	 */
	private static final String
		initializeFunctionMacroName = "MEASUREMENT_INITIALIZE_FUNCTION";

	/**
	 * "if condition" macro
	 */
	private static final String
		ifCondtionMacroName = "MEASUREMENT_IF_CONDITION";

	/**
	 * "TID condtion" macro
	 */
	private static final String
		tidCondtionMacroName = "MEASUREMENT_TID_CONDITION";

	/**
	 * "measurement start" macro
	 */
	private static final String startMacroName = "MEASUREMENT_START";

	/**
	 * "measurement stop" macro
	 */
	private static final String stopMacroName = "MEASUREMENT_STOP";

	/**
	 * "measurement step begin" macro
	 */
	private static final String stepBeginMacroName = "MEASUREMENT_STEP_BEGIN";

	/**
	 * "measurement step end" macro
	 */
	private static final String stepEndMacroName = "MEASUREMENT_STEP_END";

	/**
	 * add skip point
	 *
	 * @param start start of range
	 * @param end end of range
	 */
	private static void addSkipPoint(int start, int end) {
		measurePointList.add(new SkipPoint(start, end));
	}

	/**
	 * add replace point
	 *
	 * @param start start of range
	 * @param end end of range
	 * @param replace replace text
	 */
	private static void addReplacePoint(int start, int end, String replace)	{
		measurePointList.add(new ReplacePoint(start, end, replace));
	}

	/**
	 * add insert point
	 *
	 * @param point a point
	 * @param insertText insert text
	 */
	private static void addInsertPoint(int point, String insertText) {
		measurePointList.add(new InsertPoint(point, insertText));
	}

	/**
	 * add delete point
	 *
	 * @param start start of range
	 * @param end end of range
	 */
	private static void addDeletePoint(int start, int end) {
		measurePointList.add(new DeletePoint(start, end));
	}

	/**
	 * add measurement point
	 *
	 * @param type a type of point
	 * @param point a point
	 * @param block Block instance
	 * @param update <code>true</code> is update code
	 */
	private static void addMeasurePoint(PointType type, int point,
										Block block, boolean update) {
		measurePointList.add(new MeasurePoint(type, point, block, update));
		String p = null;
		if (type == PointType.START) {
			p = getPreamble();
		} else {
			p = getPostamble();
		}
		if (p != null) {
			addInsertPoint(point, p);
		}
	}

	/**
	 * canonicalize for BLXML name format
	 *
	 * @param name
	 *		Block/Port/Line name of Simulink
	 *
	 * @return
	 *		canicalized name
	 */
	private static String canonicalize(String name) {
		char org[] = name.toCharArray();
		int len = name.length();
		int idx = 0;
		char tmp[] = new char[len];
		for (int i = 0; i < len; i++) {
			if (org[i] == '/' || org[i] == '-') {
				tmp[idx++] = '_';
			} else if (org[i] == '_' || Character.isLetterOrDigit(org[i])) {
				tmp[idx++] = org[i];
			}
		}
		return new String(tmp, 0, idx);
	}

	/**
	 * mapping file to String
	 *
	 * @param file input file
	 *
	 * @return CharBuffer of the file, mapping only ISO-8859-1(latin)
	 *
	 * @throws IOException Exceotion for IO
	 * @throws FileNotFoundException Exceotion for FileNotFound
	 */
	private static CharBuffer mapFile(String file)
		throws IOException, FileNotFoundException {
		FileInputStream input = new FileInputStream(file);
		FileChannel channel = input.getChannel();
		long size = channel.size();
		MappedByteBuffer buffer = channel.map(MapMode.READ_ONLY, 0, size);
		return Charset.forName("ISO-8859-1").decode(buffer);
	}

	/**
	 * parse header file (hierarchy)
	 *
	 * @param inputHeader input Heder file
	 *
	 * @return <code>true</code> success, <code>false</code> error
	 *
	 * @throws IOException Exceotion for IO
	 * @throws FileNotFoundException Exceotion for FileNotFound
	 */
	private static boolean parseHeader(String inputHeader)
		throws IOException, FileNotFoundException {
		CharBuffer code = mapFile(inputHeader);

		Matcher matchMark = beginHierarchy.matcher(code);
		if (!matchMark.find()) {
			System.err.println("Error: "
							   + inputHeader
							   + ": not found hierarchy map");
			return false;
		}

		CharBuffer hierarchyCode = code.subSequence(matchMark.end(),
													code.length());
		Matcher matchHierarchy = blockHierarchy.matcher(hierarchyCode);
		while (matchHierarchy.find()) {
			if (matchHierarchy.start(1) != -1) {
				String system = matchHierarchy.group(2);
				String block = canonicalize(matchHierarchy.group(4));
				hierarchyMap.put(system, block);
				if (verbose) {
					System.out.println("System=" + system
									   + ", name=" + block);
				}
			}
		}
		return true;
	}

	/**
	 * go next line
	 *
	 * @param buffer code buffer
	 * @param point current position
	 * @param end end of code
	 *
	 * @return next begining of line
	 */
	private static int goNextLine(CharBuffer buffer, int point, int end) {
		while (point < end) {
			if (buffer.charAt(point) == '\n') {
				return point + 1;
			}
			point++;
		}
		return end;
	}

	/**
	 * go begining of line
	 *
	 * @param buffer code buffer
	 * @param point current position
	 *
	 * @return begining of this line
	 */
	private static int goBeginLine(CharBuffer buffer, int point) {
		while (point > 0) {
			if (buffer.charAt(point - 1) == '\n')
				break;
			point--;
		}
		return point;
	}

	/**
	 * find C Comment
	 *
	 * @param buffer code buffer
	 * @param start current position
	 * @param end end of code
	 *
	 * @return a Range of Comment or null(not found)
	 */
	private static Range findComment(CharBuffer buffer, int start, int end) {
		int point = start;
		int comBeg = -1;
		int comEnd = -1;

		while (point < end) {
			if (comBeg == -1
				&& end - point > 1
				&& buffer.charAt(point) == '/'
				&& buffer.charAt(point + 1) == '*') {
				comBeg = point;
			} else if (comBeg != -1
					   && end - point > 1
					   && buffer.charAt(point) == '*'
					   && buffer.charAt(point + 1) == '/') {
				comEnd = point + 2;
				return new Range(comBeg, comEnd);
			}
			point++;
		}
		return null;			// not found
	}

	/**
	 * skip white spaces and comments
	 *
	 * @param buffer code buffer
	 * @param start current position
	 * @param end end of code
	 *
	 * @return a point of statement or other(e.g. brace...)
	 */
	private static int skipComment(CharBuffer buffer, int start, int end) {
		int comment = 0;
		int point = start;

		while (point < end) {
			if (comment == 0) {
				if (end - point > 1
					&& buffer.charAt(point) == '/'
					&& buffer.charAt(point + 1) == '*') {
					comment = 1;
					point += 2;
					continue;
				} else if (!Character.isWhitespace(buffer.charAt(point))) {
					break;
				}
			} else if (end - point > 1
					   && buffer.charAt(point) == '*'
					   && buffer.charAt(point + 1) == '/') {
				comment = 0;
				point += 2;
				continue;
			}
			point++;
		}
		return point;
	}

	/**
	 * check word existing
	 *
	 * @param buffer code buffer
	 * @param start current position
	 * @param end end of code
	 * @param word check word
	 *
	 * @return an end-point of word
	 */
	private static int checkWord(CharBuffer buffer,
								 int start, int end, String word) {
		int point = skipComment(buffer, start, end);
		if (point != -1) {
			int wordEnd = point + word.length();
			if (buffer.length() - wordEnd >= 0) {
				String subStr = buffer.subSequence(point, wordEnd).toString();
				if (subStr.equals(word)) {
					return wordEnd;
				}
			}
		}
		return -1;				// not found
	}

	/**
	 * check continuous statement existing
	 * ("else"/"while" after ";" or "}")
	 *
	 * @param buffer code buffer
	 * @param start current position
	 * @param end end of code
	 *
	 * @return an end-point of statement
	 */
	private static int checkContinuousStatement(CharBuffer buffer,
												int start, int end) {
		int n = checkWord(buffer, start, end, "else");
		if (n != -1) {
			return n;
		}
		return checkWord(buffer, start, end, "while");
	}

	/**
	 * skip statement
	 *
	 * @param buffer code buffer
	 * @param start current position
	 * @param end end of code
	 * @param list output to Range of C-Block
	 *
	 * @return an end-point of statement
	 */
	private static int skipStatement(CharBuffer buffer, int start, int end,
									 List<Range> list) {
		int point = start;

		int b1 = 0;				// {}
		int b2 = 0;				// ()
		int n = 0;

		int blockStart = -1;
		int lineStart = -1;

		while (point < end) {
			point = skipComment(buffer, point, end);

			boolean semiColonEnd = (b1 == 0 && b2 == 0
									&& buffer.charAt(point) == ';');
			boolean braseEnd = (b1 == 1 && buffer.charAt(point) == '}');

			if (semiColonEnd || braseEnd) {
				// check "else" and "while"
				n = checkContinuousStatement(buffer, point + 1, end);
				if (n == -1) {
					// maybe TID/Sampletime block
					if (braseEnd && blockStart >= 0) {
						list.add(new Range(blockStart,
										   goBeginLine(buffer, point)));
					}
					return point + 1;
				}
			}

			if (buffer.charAt(point) == '{') {
				b1++;
				if (b1 == 1) {
					if (blockStart == -1) {
						blockStart = goNextLine(buffer, point, end);
					} else {
						blockStart = -2; // multiple block
					}
				}
			} else if (buffer.charAt(point) == '}') {
				if (b1 == 0) {
					System.err.println("Error: brace mismatch at ["
									   + start + ":" + point + ":" + end + "]");
				} else {
					b1--;
				}
			}
			if (buffer.charAt(point) == '(') {
				b2++;
			} else if (buffer.charAt(point) == ')') {
				if (b2 == 0) {
					System.err.println("Error: braket mismatch at ["
									   + start + ":" + point + ":" + end + "]");
				} else {
					b2--;
				}
			}
			point++;
		}
		return point;
	}

	/**
	 * code information
	 *
	 * @param p point in CharBuffer
	 * @param r restart flag
	 */
	private static void pushState(int p, boolean r) {
		stateStack.add(new SaveState(startComment, endComment,
									 startStatement,  endStatement,
									 startBlock,  endBlock,
									 tidInfo, p, codeEnd, startBlockComment,
									 currentBlock, isUpdate, hasIf,
									 preamble, postamble, r));
	}

	/**
	 * push state (restart flag only)
	 *
	 * @param r restart flag
	 */
	private static void pushState(boolean r) {
		pushState(parsePoint, r);
	}

	/**
	 * push state (all)
	 */
	private static void pushState() {
		pushState(parsePoint, restart);
	}

	/**
	 * pop state
	 *
	 * @return <code>false</code> underflow
	 */
	private static boolean popState() {
		int index = stateStack.size() - 1;
		if (index < 0) {
			return false;
		}
		SaveState currentState = stateStack.get(index);
		stateStack.remove(index);

		startComment = currentState.startComment;
		endComment = currentState.endComment;
		startStatement = currentState.startStatement;
		endStatement = currentState.endStatement;
		startBlock = currentState.startBlock;
		endBlock = currentState.endBlock;
		tidInfo = currentState.tidInfo;
		parsePoint = currentState.parsePoint;
		codeEnd = currentState.codeEnd;
		startBlockComment = currentState.startBlockComment;
		currentBlock = currentState.currentBlock;
		isUpdate = currentState.isUpdate;
		hasIf = currentState.hasIf;
		preamble = currentState.preamble;
		postamble = currentState.postamble;
		restart = currentState.restart;

		return true;
	}

	/**
	 * reset state (except ParsePoint and codeEnd)
	 *
	 * @param p new ParsePoint value
	 * @param e new codeEnd value
	 */
	private static void resetState(int p, int e) {
		parsePoint = p;
		codeEnd = e;

		startComment = -1;
		endComment = -1;
		startStatement = -1;
		endStatement = -1;
		startBlock = -1;
		endBlock = -1;
		tidInfo = null;
		startBlockComment = -1;
		currentBlock = null;
		isUpdate = false;
		hasIf = false;
		preamble = null;
		postamble = null;
		restart = false;
	}

	/**
	 * is state stack empty
	 *
	 * @return <code>true</code> empty
	 */
	private static boolean isEmpyState() {
		return stateStack.size() == 0;
	}

	/**
	 * get block
	 *
	 * @param blockMatcher Matcher of block's comment
	 *
	 * @return Block block
	 */
	private static Block getBlock(Matcher blockMatcher) {
		String sys = blockMatcher.group(indexSystem);
		String hierarchy;
		String name;
		Block block;

		if (blockMatcher.start(indexCCB) != -1) {
			// ConcatBufferAt...
			name = blockMatcher.group(indexCCB);
			hierarchy = new String(sys + "/" + name);
		} else if (blockMatcher.start(indexSC) != -1) {
			// TmpSignal ConversionAt...
			name = blockMatcher.group(indexSC);
			hierarchy = new String(sys + "/" + name);
		} else {
			hierarchy = blockMatcher.group(indexBlock);
			name = blockMatcher.group(indexName);
		}

		if (verbose) {
			System.out.println("* Sys="
							   + sys
							   + ",name=|"
							   + name
							   + "|"
							   + (isUpdate ? ",Update" : ""));
		}
		String prefix = hierarchyMap.get(sys);
		if (prefix != null) {
			block = blockMap.get(hierarchy);
			if (block == null) {
				block = new Block(hierarchy, sys, prefix, name);
			}
			return block;
		}

		// error
		System.err.println("Error: " + sys + ": no hierarchy");
		return null;
	}

	/**
	 * get preamble
	 *
	 * @return preamble code
	 */
	private static String getPreamble() {
		String p = null;
		for (SaveState ss : stateStack) {
			if (ss.preamble != null) {
				if (p == null) {
					p = ss.preamble.toString();
				} else {
					p += ss.preamble;
				}
			}
		}
		if (preamble != null) {
			if (p == null) {
				p = preamble.toString();
			} else {
				p += preamble;
			}
		}
		return p;
	}

	/**
	 * get postamble
	 *
	 * @return postamble code
	 */
	private static String getPostamble() {
		String p = null;
		if (postamble != null) {
			if (p == null) {
				p = postamble.toString();
			} else {
				p += postamble;
			}
		}
		for (int i = stateStack.size() - 1; i >= 0; i--) {
			SaveState ss = stateStack.get(i);
			if (ss.preamble != null) {
				if (p == null) {
					p = ss.preamble.toString();
				} else {
					p += ss.preamble;
				}
			}
		}
		return p;
	}

	/**
	 * parse C Code
	 *
	 * @param code code's CharBuffer
	 * @param inputSource source file
	 *
	 * @return <code>true</code> success, <code>false</code> error
	 * @throws IOException Exceotion for IO
	 */
	private static boolean parseCode(CharBuffer code,
									 String inputSource) throws IOException {
		int lastInclude = -1;

		Matcher stepFunctionMatcher = stepFunction.matcher(code);
		while (stepFunctionMatcher.find()) {
			if (stepFunctionMatcher.start(1) != -1) {
				parsePoint = stepFunctionMatcher.end();
				stepFunctionName = stepFunctionMatcher.group(2);
				break;
			} else if (stepFunctionMatcher.start(3) != -1) {
				lastInclude = stepFunctionMatcher.end();
			} else if (stepFunctionMatcher.start(4) != -1) {
				initializeFunctionName = stepFunctionMatcher.group(5);
			}
		}

		if (parsePoint == -1) {
			System.err.println("Error: "
							   + inputSource
							   + ": not found step function");
			return false;
		}

		if (lastInclude != -1) {
			addMeasurePoint(PointType.INCLUDE, lastInclude, null, false);
			if (verbose) {
				System.out.println("lastInclude: " + lastInclude);
			}
		}

		codeEnd = code.length();

		startComment = -1;
		endComment = -1;
		startStatement = -1;
		endStatement = -1;
		startBlock = -1;
		endBlock = -1;
		tidInfo = null;
		restart = false;
		startBlockComment = -1;
		currentBlock = null;
		isUpdate = false;
		hasIf = false;
		preamble = null;
		postamble = null;

		List<String> blocks = new ArrayList<String>();

		boolean firstComment = true;
		boolean firstBlockStatement = true;
		int lastBlockStatementEnd = -1;
		Block skipToEndBlock = null;

		pushState();

		while (popState()) {
			while (parsePoint < codeEnd) {
				if (code.charAt(parsePoint) == '}') {
					break;
				}

				if (!restart) {
					// find statement
					if (endStatement == -1 || endStatement <= parsePoint) {
						int tmp = skipComment(code, parsePoint, codeEnd);
						startStatement = goBeginLine(code, tmp);
						if (code.charAt(startStatement) == '}') {
							// reach to end of step function
							codeEnd = startStatement;
							startStatement = -1;
							endStatement = -1;

							// check out of bound
							if (startComment != -1
								&& codeEnd <= startComment) {
								startComment = -1;
								endComment = -1;
							}
						}
					}

					if (endComment == -1 || endComment <= parsePoint) {
						Range comArea = findComment(code, parsePoint, codeEnd);
						if (comArea != null) {
							startComment = goBeginLine(code,
													   comArea.getStart());
							endComment = goNextLine(code,
													comArea.getEnd(), codeEnd);
						}
					}
				} else if (verbose) {
					int tidIndex = -1;
					if (tidInfo != null) {
						tidIndex = tidInfo.getTidIndex();
					}
					System.out.println("Restart: "
									   + parsePoint
									   + ":" + codeEnd
									   + "," + startComment
									   + ":" + endComment
									   + "," + startStatement
									   + ":" + endStatement
									   + "," + startBlock
									   + ":" + endBlock
									   + "," + tidIndex
									   + "," + (restart ? "true" : "false"));
				}

				// *** restart point ***

				if (startStatement != -1
					&& (startComment == -1 || startStatement < startComment)) {
					// check multirate and if condtin when not restarting
					if (!restart) {
						List<Range> list = new ArrayList<Range>();
						int tmp = skipStatement(code,
												startStatement, codeEnd, list);
						endStatement = goNextLine(code, tmp, codeEnd);

						startBlock = -1;
						endBlock = -1;
						tidInfo = null;

						if (skipToEndBlock == null && list.size() > 0) {
							Range t = list.get(0);
							startBlock = t.getStart();
							endBlock = t.getEnd();

							CharBuffer
								ifCode = code.subSequence(startStatement,
														  startBlock);

							// check TID[]
							Matcher tidMatcher = tidPattern.matcher(ifCode);
							if (tidMatcher.find()) {
								// output to stop measurement
								if (lastBlockStatementEnd != -1
									&&currentBlock != null) {
									addMeasurePoint(PointType.STOP,
													lastBlockStatementEnd,
													currentBlock, isUpdate);
									lastBlockStatementEnd = -1;
								}

								String tid = tidMatcher.group(3);
								int tidIndex = Integer.parseInt(tid);
								int s = startStatement + tidMatcher.start(1);
								int e = startStatement + tidMatcher.end(1);

								tidInfo = new TIDInfo(tidIndex, s, e);

								// enter if then block
								pushState(true);
								resetState(startBlock, endBlock);
								continue;
							}

							// Change "if Condition"
							if (hasIf) {
								hasIf = false;
								Matcher ifMatcher = ifPattern.matcher(ifCode);
								if (ifMatcher.find()) {
									int s = startStatement + ifMatcher.start(1);
									int e = startStatement + ifMatcher.end(1);
									addInsertPoint(s, macroPrefix
												   + ifCondtionMacroName
												   + "(");
									addInsertPoint(e, ")");
								}
							} else if (startStatement < startComment
									   && startComment < endStatement) {
								// A Statement is breaked by Comment
								CharBuffer
									subCode = code.subSequence(startComment,
															   endComment);
								Matcher
									blockMatcher = blockMark.matcher(subCode);
								if (blockMatcher.find()) {
									// output to stop measurement
									if (lastBlockStatementEnd != -1
										&&currentBlock != null) {
										addMeasurePoint(PointType.STOP,
														lastBlockStatementEnd,
														currentBlock, isUpdate);
										lastBlockStatementEnd = -1;
									}

									currentBlock = null;

									CharBuffer
										pre = code.subSequence(startStatement,
															   startBlock);
									CharBuffer
										post = code.subSequence(endBlock,
																endStatement);

									addDeletePoint(startStatement, startBlock);
									addDeletePoint(endBlock, endStatement);

									pushState(true);
									resetState(startBlock, endBlock);

									preamble = pre;
									postamble = post;
									continue;
								}
							}
							preamble = null;
							postamble = null;
						}
					}

					CharBuffer subCode = code.subSequence(startStatement,
														  endStatement);
					// Block code
					CharBuffer frontCode = null;
					CharBuffer blockCode = null;
					CharBuffer backCode = null;

					if (startBlock != -1) {
						frontCode = code.subSequence(startStatement,
													 startBlock);
						blockCode = code.subSequence(startBlock,
													 endBlock);
						backCode = code.subSequence(endBlock,
													endStatement);
					}

					if (verbose) {
						System.out.println("---- Begin Statement ----");
						if (startBlock == -1) {
							System.out.print(subCode.toString());
						} else {
							System.out.print(frontCode.toString());
							if (tidInfo != null) {
								System.out.println("*** Multirate Block ("
												   + tidInfo.getTidIndex()
												   + ") ****\n"
												   + blockCode.toString()
												   + "**** End Multirate "
												   + "Block ("
												   + tidInfo.getTidIndex()
												   + ") ****");
							} else {
								System.out.println("@@@@ Block @@@@\n"
												   + blockCode.toString()
												   + "@@@@ End Block @@@@");
							}
							System.out.print(backCode.toString());
						}
						System.out.println("---- End Statement ----");
					}

					if (currentBlock != null && firstBlockStatement) {
						firstBlockStatement = false;
						addMeasurePoint(PointType.START, startBlockComment,
										currentBlock, isUpdate);
					}

					if (startBlock != -1 && tidInfo != null) {
						addInsertPoint(tidInfo.getStartOfCondtion(),
									   macroPrefix + tidCondtionMacroName
									   + "(");
						addInsertPoint(tidInfo.getEndOfCondition(), ")");
					} else {
						lastBlockStatementEnd = endStatement;
					}

					parsePoint = endStatement;
					startStatement = -1;
					endStatement = -1;
				} else if (startComment != -1) {
					CharBuffer subCode = code.subSequence(startComment,
														  endComment);

					if (verbose) {
						int tidIndex = -1;
						if (tidInfo != null) {
							tidIndex = tidInfo.getTidIndex();
						}
						System.out.println("==== Begin Comment ["
										   + parsePoint
										   + ":" + codeEnd
										   + "," + startComment
										   + ":" + endComment
										   + "," + startStatement
										   + ":" + endStatement
										   + "," + startBlock
										   + ":" + endBlock
										   + "," + tidIndex
										   + "," + (restart ? "true" : "false")
										   + "] ====\n"
										   + subCode
										   + "==== End Comment ====");
					}

					boolean isBlockComment = false;
					Matcher blockEndMatcher = blockEndMark.matcher(subCode);
					Matcher blockMatcher = blockMark.matcher(subCode);
					if (blockEndMatcher.find()) {
						if (lastBlockStatementEnd != -1
							&& currentBlock != null) {
							addMeasurePoint(PointType.STOP,
											lastBlockStatementEnd,
											currentBlock, isUpdate);
							lastBlockStatementEnd = -1;
						}
						currentBlock = null;
					} else if (blockMatcher.find()) {
						Block tmpBlock = getBlock(blockMatcher);

						isBlockComment = true;

						if (skipToEndBlock != null) {
							if (skipToEndBlock == tmpBlock
								&& blockMatcher.start(indexEndOf) != -1) {
								skipToEndBlock = null; // finish
							} else {
								isBlockComment = false; // ignore
							}
						}

						if (skipToEndBlock == null
							&& lastBlockStatementEnd != -1
							&& currentBlock != null) {
							addMeasurePoint(PointType.STOP,
											lastBlockStatementEnd,
											currentBlock, isUpdate);
							lastBlockStatementEnd = -1;
						}

						boolean handled = false;

						if (skipToEndBlock == null
							&& blockMatcher.start(indexEndOf) == -1
							&& blockMatcher.start(indexBlock) != -1) {

							String blockType = blockMatcher.group(indexType);

							if (blockMatcher.start(indexUpdateOf) != -1
								||  blockMatcher.start(indexSfUpdate) != -1) {
								// Update
								isUpdate = true;
							} else {
								isUpdate = false;
							}

							SubsystemType subsystemType = SubsystemType.NONE;

							if (blockMatcher.start(indexSubSys) != -1) {
								String
									subtype = blockMatcher.group(indexSubSys);
								// TODO: EnabledTriggered SubSystem
								if (subtype.equals("Atomic")) {
									subsystemType = SubsystemType.ATOMIC;
								}
								else if (subtype.equals("Enable")) {
									hasIf = true;
									subsystemType = SubsystemType.ENABLED;
								}
								else if (subtype.equals("Triggered")) {
									hasIf = true;
									subsystemType = SubsystemType.TRIGGERED;
								}
								else if (subtype.equals("Action")) {
									subsystemType = SubsystemType.ACTION;
								}
								else if (subtype.equals("Iterator")) {
									subsystemType = SubsystemType.ITERATOR;
								}
							}

							if (tmpBlock != null) {
								firstBlockStatement = true;
								startBlockComment = startComment;
								currentBlock = tmpBlock;
								handled = true;

								if (subsystemType == SubsystemType.ITERATOR
									|| blockType.equals("DotProduct")) {
									skipToEndBlock = currentBlock;
								}
							}
						}

						if (skipToEndBlock == null && !handled) {
							currentBlock = null;
							isUpdate = false;
							firstBlockStatement = false;
							hasIf = false;
						}
					}

					if (isBlockComment && firstComment) {
						addMeasurePoint(PointType.STEP_BEGIN,
										startComment, null, false);
						firstComment = false;
					}

					if (!isBlockComment && verbose) {
						System.out.println("---- Ignore Comment ----\n"
										   + subCode
										   + "---- End of Ignore Comment ---");
					}

					parsePoint = endComment;
					startComment = -1;
					endComment = -1;
				}

				restart = false;
			}
			if (lastBlockStatementEnd != -1 && currentBlock != null) {
				addMeasurePoint(PointType.STOP, lastBlockStatementEnd,
								currentBlock, isUpdate);
				lastBlockStatementEnd = -1;
			}
		}

		if (parsePoint != codeEnd) {
			addMeasurePoint(PointType.STEP_END, parsePoint, null, false);
		}

		if (stepFunctionName == null) {
			System.err.println("Error: step function not found");
			return false;
		}

		if (initializeFunctionName == null) {
			parsePoint = goNextLine(code, parsePoint, code.length());
			if (stepFunctionMatcher.find(parsePoint)) {
				if (stepFunctionMatcher.start(4) != -1) {
					initializeFunctionName = stepFunctionMatcher.group(5);
				} else {
					while (stepFunctionMatcher.find()) {
						if (stepFunctionMatcher.start(4) != -1) {
							initializeFunctionName = stepFunctionMatcher.group(5);
							break;
						}
					}
				}
			}
		}

		return true;
	}

	/**
	 * return sorted Block Map
	 *
	 * @return sorted list of Map Entries
	 */
	private static List<Entry<String, Block>> sortedBlockMap() {
		List<Entry<String, Block>>
			entries = new ArrayList<Entry<String, Block>>(blockMap.entrySet());
		Collections.sort(entries, new Comparator<Entry<String, Block>>() {
				public int compare(Entry<String, Block> ea,
								   Entry<String, Block> eb) {
					Block ba = ea.getValue();
					Block bb = eb.getValue();

					int diff = ba.getSystemId() - bb.getSystemId();
					if (diff != 0) {
						return diff;
					}
					return ba.getName().compareTo(bb.getName());
				}
			});
		return entries;
	}

	/**
	 * output macro file
	 *
	 * @param entries list of Map Entries
	 *
	 * @throws IOException exception of IO
	 * @throws FileNotFoundException exception of FileNotFound
	 */
	private static void outputMacro(List<Entry<String, Block>> entries)
		throws IOException, FileNotFoundException {
		PrintStream output = new PrintStream(outputMacroName);

		String hdrName = outputMacroName.replaceAll("[^\\p{Alnum}]",
													"_").toUpperCase();

		output.println("/*\n * generated by AddMeasurement\n"
					   + " *\n * DO NOT CHANGE THIS FILE\n */\n");

		output.println("#ifndef " + hdrName + "\n" + "#define " + hdrName);

		if (blockNameMap.size() > 0) {

			output.println("\n/* Block IDs */");
			for (Entry<String, Block> entry : entries) {
				Block block = entry.getValue();
				String macroName = block.getBlockName().toUpperCase();
				output.println("#define " + macroPrefix
							   + macroName + " " + block.getId());
			}

			output.println("\n/* Maximum Block ID */\n"
						   + "#define " + macroPrefix
						   + "MAX_BLOCK_ID " + blockNameMap.size());

			output.println("\n/* Block Parameters */");
			for (Entry<String, Block> entry : entries) {
				Block block = entry.getValue();
				String macroName = block.getBlockName().toUpperCase();
				output.println("#ifndef " + macroPrefix + macroName + "_PARAM"
							   + "\n#define " + macroPrefix + macroName
							   + "_PARAM\t0\n#endif");
			}

			output.println("\n/*\n * Block Names\n */\nconst char *"
						   + macroPrefix
						   + "BLOCK_NAMES[] = {");
			for (Entry<String, Block> entry : entries) {
				Block block = entry.getValue();
				String name = block.getBlockName();
				output.println("\t\"" + name + "\",");
			}
			output.println("};");
		}

		output.println("\n#define " + macroPrefix
					   + stepFunctionMacroName + "\t" + stepFunctionName);

		if (initializeFunctionName != null) {
			output.println("#define " + macroPrefix
						   + initializeFunctionMacroName + "\t"
						   + initializeFunctionName);
		}

		output.println("\n#endif");
	}


	/**
	 * output measurement code
	 *
	 * @param outputCode a file name of measurement code
	 * @param inputBuffer input code CharBuffer
	 *
	 * @throws IOException exception of IO
	 * @throws FileNotFoundException exception of FileNotFound
	 */
	private static void outputCode(String outputCode,
								   CharBuffer inputBuffer)
		throws IOException, FileNotFoundException {
		PrintStream  output;
		int filePosition = 0;

		if (outputCode != null) {
			output = new PrintStream(outputCode);
		} else {
			output = System.out;
		}

		measurePointList.sort(new PointBaseComparator());
		for (PointBase pointBase : measurePointList) {
			int point = pointBase.getPoint();
			if (filePosition < point) {
				CharBuffer
					subCode = inputBuffer.subSequence(filePosition, point);
				output.print(subCode);
				filePosition = point;
			}

			if (pointBase instanceof ReplacePoint) {
				ReplacePoint replacePoint = (ReplacePoint)pointBase;
				output.print(inputBuffer.subSequence(filePosition,
													 replacePoint.getStart()));
				output.print("/*");
				output.print(inputBuffer.subSequence(replacePoint.getStart(),
													 replacePoint.getEnd()));
				output.print("*/" + replacePoint.getReplace());
				filePosition = replacePoint.getEnd();
			} else if (pointBase instanceof SkipPoint) {
				SkipPoint skipPoint = (SkipPoint)pointBase;
				output.println("#if 0 /**** BEGIN SKIP ****/");
				output.print(inputBuffer.subSequence(skipPoint.getStart(),
													 skipPoint.getEnd()));
				output.println("#endif /**** END SKIP ****/");
				filePosition = pointBase.getEnd();
			} else if (pointBase instanceof InsertPoint) {
				InsertPoint insertPoint = (InsertPoint)pointBase;
				output.print(insertPoint.getInsertText());
			} else if (pointBase instanceof DeletePoint) {
				filePosition = pointBase.getEnd();
			} else if (pointBase instanceof MeasurePoint) {
				MeasurePoint measurePoint = (MeasurePoint)pointBase;
				Block block = measurePoint.getBlock();
				PointType type = measurePoint.getType();
				String macroBlockName = null;
				String updateParam = null;
				int index = -1;
				if (block != null) {
					macroBlockName = block.getBlockName().toUpperCase();
					if (measurePoint.isUpdate()) {
						updateParam = "1";
						if (type == PointType.START) {
							index = block.incrementUpdateCount();
						} else {
							index = block.getUpdateCount();
						}
					} else {
						updateParam = "0";
						if (type == PointType.START) {
							index = block.incrementBlockCount();
						} else {
							index = block.getBlockCount();
						}
					}
				}

				switch (type) {
				case INCLUDE:
					output.println("\n/* user include files */");
					output.println("#include \"" + outputMacroName + "\"");
					for (String includeFile : includeFiles) {
						output.println("#include \"" + includeFile + "\"");
					}
					output.println("\n"
								   + "/*\n"
								   + " * empty measurement macros\n"
								   + " */\n"
								   + "#ifndef " + macroPrefix
								   + startMacroName + "\n"
								   + "#define " + macroPrefix
								   + startMacroName + "(ID,UPD,INDEX,PARAM)\t"
								   + "do { ; } while (0)\n"
								   + "#endif\n"
								   + "#ifndef " + macroPrefix
								   + stopMacroName + "\n"
								   + "#define " + macroPrefix
								   + stopMacroName + "(ID,UPD,INDEX,PARAM)\t"
								   + "do { ; } while (0)\n"
								   + "#endif\n"
								   + "#ifndef " + macroPrefix
								   + stepBeginMacroName + "\n"
								   + "#define " + macroPrefix
								   + stepBeginMacroName + "()\t"
								   + "do { ; } while (0)\n"
								   + "#endif\n"
								   + "#ifndef " + macroPrefix
								   + stepEndMacroName + "\n"
								   + "#define " + macroPrefix
								   + stepEndMacroName + "()\t"
								   + "do { ; } while (0)\n"
								   + "#endif\n"
								   + "#ifndef " + macroPrefix
								   + ifCondtionMacroName + "\n"
								   + "#define " + macroPrefix
								   + ifCondtionMacroName + "(X)\tX\n"
								   + "#endif\n"
								   + "#ifndef " + macroPrefix
								   + tidCondtionMacroName + "\n"
								   + "#define " + macroPrefix
								   + tidCondtionMacroName + "(X)\tX\n"
								   + "#endif");
					break;

				case START:
					output.println(macroPrefix + startMacroName + "("
								   + macroPrefix + macroBlockName
								   + "," + updateParam
								   + "," + index
								   + "," + macroPrefix
								   + macroBlockName + "_PARAM"
								   + ");");
					break;

				case STOP:
					output.println(macroPrefix + stopMacroName + "("
								   + macroPrefix + macroBlockName
								   + "," + updateParam
								   + "," + index
								   + "," + macroPrefix
								   + macroBlockName + "_PARAM"
								   + ");");
					break;

				case STEP_BEGIN:
					output.println(macroPrefix + stepBeginMacroName + "();");
					break;

				case STEP_END:
					output.println(macroPrefix + stepEndMacroName + "();");
					break;
				}
			}
		}

		if (filePosition < inputBuffer.length()) {
			CharBuffer
				subCode = inputBuffer.subSequence(filePosition,
												  inputBuffer.length());
			output.print(subCode);
		}
	}

	/**
	 * output block information to CSV file
	 *
	 * @param file output file name
	 * @param entries list of Block Map entries
	 *
	 * @throws IOException exception of IO
	 * @throws FileNotFoundException exception of FileNotFound
	 */
	private static void outputBlock(String file,
									List<Entry<String, Block>> entries)
		throws IOException, FileNotFoundException {

		PrintStream output = new PrintStream(file);
		output.println("# hierarchy, ID Number, blockName, Identifier");
		for (Entry<String, Block> entry : entries) {
			Block block = entry.getValue();
			output.println("\"" + block.getBlock()
						   + "\"," + block.getId()
						   + "," + block.getBlockName()
						   + "," + macroPrefix
						   + block.getBlockName().toUpperCase());
		}
	}

	/**
	 * output usage and exit
	 */
	private static void usage() {
		System.err.println("Usage: "
						   + "AddMeasurment"
						   + " [-v]"
						   + " [-o output.c] "
						   + " [-m output.h] "
						   + " [-i includes] "
						   + " [-b blocks.csv] "
						   + " -h header"
						   + " c_source");
		System.exit(1);
	}

	/**
	 *
	 * main
	 *
	 * @param args command line arguments
	 *
	 */
	public static void main(String args[]) {
		String inputSource = null;
		String inputHeader = null;
		String outputCode = null;
		String outputBlockName = null;

		Getopts getOpts = new Getopts();

		char c;
		while ((c = getOpts.getopt(args, "vo:m:p:b:i:h:")) != '\0') {
			switch (c) {
			case 'v':
				verbose = true;
				break;
			case 'o':
				outputCode = getOpts.optarg;
				break;
			case 'm':
				outputMacroName = getOpts.optarg;
				break;
			case 'p':
				macroPrefix = getOpts.optarg;
				break;
			case 'b':
				outputBlockName = getOpts.optarg;
				break;
			case 'i':
				includeFiles.add(getOpts.optarg);
				break;
			case 'h':
				inputHeader = getOpts.optarg;
				break;
			case '?':
				usage();
			}
		}

		if (getOpts.optind < args.length) {
			inputSource = args[getOpts.optind];
		}

		if (inputSource == null || inputHeader == null) {
			usage();
		}

		if (verbose && outputCode == null) {
			System.err.println("no -o option, ignore -v");
			verbose = false;
		}

		try {
			if (!parseHeader(inputHeader)) {
				System.exit(1);
			}

			CharBuffer codeBuffer = mapFile(inputSource);
			if (!parseCode(codeBuffer, inputSource)) {
				System.exit(1);
			}

			outputCode(outputCode, codeBuffer);

			List<Entry<String, Block>> entries = sortedBlockMap();
			int id = 0;
			for (Entry<String, Block> entry : entries) {
				Block block = entry.getValue();
				block.setId(id++);
			}

			outputMacro(entries);
			if (outputBlockName != null) {
				outputBlock(outputBlockName, entries);
			}

			System.exit(0);
		}
		catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		catch (IOException e) {
			e.printStackTrace();
		}

		System.exit(1);
	}
}
